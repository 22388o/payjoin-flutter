// This file is automatically generated, so please do not edit it.
// Generated by `flutter_rust_bridge`@ 2.0.0-dev.24.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import '../utils/error.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// Rust type: RustOpaqueMoi<Arc < payjoin_ffi :: receive :: MaybeInputsOwned >>
@sealed
class ArcPayjoinFfiReceiveMaybeInputsOwned extends RustOpaque {
  ArcPayjoinFfiReceiveMaybeInputsOwned.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  ArcPayjoinFfiReceiveMaybeInputsOwned.sseDecode(
      int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_ArcPayjoinFfiReceiveMaybeInputsOwned,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcPayjoinFfiReceiveMaybeInputsOwned,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_ArcPayjoinFfiReceiveMaybeInputsOwnedPtr,
  );
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::rust_async::RwLock<Box < dyn Fn (Vec < u8 >) -> Result < bool , PayjoinError > + Send + Sync >>>
@sealed
class BoxFnVecU8ResultBoolPayjoinError extends RustOpaque {
  BoxFnVecU8ResultBoolPayjoinError.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  BoxFnVecU8ResultBoolPayjoinError.sseDecode(int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_BoxFnVecU8ResultBoolPayjoinError,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_BoxFnVecU8ResultBoolPayjoinError,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_BoxFnVecU8ResultBoolPayjoinErrorPtr,
  );
}

// Rust type: RustOpaqueMoi<payjoin_ffi :: receive :: UncheckedProposal>
@sealed
class PayjoinFfiReceiveUncheckedProposal extends RustOpaque {
  PayjoinFfiReceiveUncheckedProposal.dcoDecode(List<dynamic> wire)
      : super.dcoDecode(wire, _kStaticData);

  PayjoinFfiReceiveUncheckedProposal.sseDecode(
      int ptr, int externalSizeOnNative)
      : super.sseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_PayjoinFfiReceiveUncheckedProposal,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_PayjoinFfiReceiveUncheckedProposal,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_PayjoinFfiReceiveUncheckedProposalPtr,
  );
}

class Headers {
  final Map<String, String> field0;

  const Headers({
    required this.field0,
  });

  static Future<Headers> fromVec({required List<int> body, dynamic hint}) =>
      RustLib.instance.api.headersFromVec(body: body, hint: hint);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Headers &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class MaybeInputsOwned {
  final ArcPayjoinFfiReceiveMaybeInputsOwned field0;

  const MaybeInputsOwned({
    required this.field0,
  });

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MaybeInputsOwned &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}

class UncheckedProposal {
  final PayjoinFfiReceiveUncheckedProposal field0;

  const UncheckedProposal({
    required this.field0,
  });

  /// Call after checking that the Original PSBT can be broadcast.
  ///
  /// Receiver MUST check that the Original PSBT from the sender can be broadcast, i.e. testmempoolaccept bitcoind rpc returns { “allowed”: true,.. } for get_transaction_to_check_broadcast() before calling this method.
  ///
  /// Do this check if you generate bitcoin uri to receive Payjoin on sender request without manual human approval, like a payment processor. Such so called “non-interactive” receivers are otherwise vulnerable to probing attacks. If a sender can make requests at will, they can learn which bitcoin the receiver owns at no cost. Broadcasting the Original PSBT after some time in the failure case makes incurs sender cost and prevents probing.
  ///
  /// Call this after checking downstream.
  Future<MaybeInputsOwned> checkBroadcastSuitability(
          {int? minFeeRate,
          required BoxFnVecU8ResultBoolPayjoinError canBroadcast,
          dynamic hint}) =>
      RustLib.instance.api.uncheckedProposalCheckBroadcastSuitability(
        that: this,
        minFeeRate: minFeeRate,
        canBroadcast: canBroadcast,
      );

  /// The Sender’s Original PSBT
  Future<Uint8List> extractTxToScheduleBroadcast({dynamic hint}) =>
      RustLib.instance.api.uncheckedProposalExtractTxToScheduleBroadcast(
        that: this,
      );

  static Future<UncheckedProposal> fromRequest(
          {required List<int> body,
          required String query,
          required Headers headers,
          dynamic hint}) =>
      RustLib.instance.api.uncheckedProposalFromRequest(
          body: body, query: query, headers: headers, hint: hint);

  @override
  int get hashCode => field0.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is UncheckedProposal &&
          runtimeType == other.runtimeType &&
          field0 == other.field0;
}
